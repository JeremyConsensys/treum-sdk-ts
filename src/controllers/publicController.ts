/**
 * Treum Platform APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  CollectionStats,
  collectionStatsSchema,
} from '../models/collectionStats';
import { GetClaimOutput, getClaimOutputSchema } from '../models/getClaimOutput';
import { OrderBy10Enum, orderBy10EnumSchema } from '../models/orderBy10Enum';
import {
  OrderDirection9Enum,
  orderDirection9EnumSchema,
} from '../models/orderDirection9Enum';
import {
  PaymentsCancelCheckoutInput,
  paymentsCancelCheckoutInputSchema,
} from '../models/paymentsCancelCheckoutInput';
import {
  PublicCollectionOutput,
  publicCollectionOutputSchema,
} from '../models/publicCollectionOutput';
import {
  PublicGetCapabilitiesOutput,
  publicGetCapabilitiesOutputSchema,
} from '../models/publicGetCapabilitiesOutput';
import {
  PublicGetContractOutput,
  publicGetContractOutputSchema,
} from '../models/publicGetContractOutput';
import {
  PublicGetItemHistoryViewResponse,
  publicGetItemHistoryViewResponseSchema,
} from '../models/publicGetItemHistoryViewResponse';
import { PublicItem, publicItemSchema } from '../models/publicItem';
import {
  PublicItemOwnership,
  publicItemOwnershipSchema,
} from '../models/publicItemOwnership';
import {
  PublicItemOwnersOutput,
  publicItemOwnersOutputSchema,
} from '../models/publicItemOwnersOutput';
import {
  PublicItemsPaginatedResult,
  publicItemsPaginatedResultSchema,
} from '../models/publicItemsPaginatedResult';
import { PublicNetwork, publicNetworkSchema } from '../models/publicNetwork';
import {
  PublicOrganizationSchemaV2,
  publicOrganizationSchemaV2Schema,
} from '../models/publicOrganizationSchemaV2';
import {
  PublicRedeemClaimBody,
  publicRedeemClaimBodySchema,
} from '../models/publicRedeemClaimBody';
import { StatusResponse, statusResponseSchema } from '../models/statusResponse';
import { array, number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class PublicController extends BaseController {
  /**
   * Get known contract capabilities
   *
   * @return Response from the API call
   */
  async getKnownContractCapabilities(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicGetCapabilitiesOutput[]>> {
    const req = this.createRequest('GET', '/api/v2/public/capabilities');
    req.header('Content-Type', 'application/json');
    return req.callAsJson(
      array(publicGetCapabilitiesOutputSchema),
      requestOptions
    );
  }

  /**
   * Get the Application Binary Interface (ABI) for a specific capability
   *
   * @param capability
   * @return Response from the API call
   */
  async getTheApplicationBinaryInterfaceABIForASpecificCapability(
    capability: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicGetCapabilitiesOutput>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ capability: [capability, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/capabilities/${mapped.capability}`;
    return req.callAsJson(publicGetCapabilitiesOutputSchema, requestOptions);
  }

  /**
   * Get collection stats
   *
   * @param collectionId
   * @return Response from the API call
   */
  async getCollectionStats(
    collectionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CollectionStats>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ collectionId: [collectionId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/collection-stats/${mapped.collectionId}`;
    return req.callAsJson(collectionStatsSchema, requestOptions);
  }

  /**
   * Get metadata for a specific token in a collection
   *
   * @param collectionId
   * @param tokenId
   * @return Response from the API call
   */
  async getMetadataForASpecificTokenInACollection(
    collectionId: string,
    tokenId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      tokenId: [tokenId, number()],
    });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/collection/${mapped.collectionId}/metadata/${mapped.tokenId}`;
    return req.call(requestOptions);
  }

  /**
   * Get global contract addresses
   *
   * @param networkId
   * @return Response from the API call
   */
  async getGlobalContractAddresses(
    networkId: number[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicGetContractOutput[]>> {
    const req = this.createRequest('GET', '/api/v2/public/contracts');
    const mapped = req.prepareArgs({ networkId: [networkId, array(number())] });
    req.header('Content-Type', 'application/json');
    req.query('network_id', mapped.networkId);
    return req.callAsJson(array(publicGetContractOutputSchema), requestOptions);
  }

  /**
   * Public items have been minted, and each has a valid token address and token id.
   *
   * @param itemId
   * @return Response from the API call
   */
  async getAPublicItemById(
    itemId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicItem>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ itemId: [itemId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/items/${mapped.itemId}`;
    return req.callAsJson(publicItemSchema, requestOptions);
  }

  /**
   * Get item history
   *
   * @param itemId
   * @return Response from the API call
   */
  async getItemHistory(
    itemId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicGetItemHistoryViewResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ itemId: [itemId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/items/${mapped.itemId}/history`;
    return req.callAsJson(
      publicGetItemHistoryViewResponseSchema,
      requestOptions
    );
  }

  /**
   * Get item owners
   *
   * @param itemId
   * @return Response from the API call
   */
  async getItemOwners(
    itemId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicItemOwnersOutput[]>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ itemId: [itemId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/items/${mapped.itemId}/owners`;
    return req.callAsJson(array(publicItemOwnersOutputSchema), requestOptions);
  }

  /**
   * Get all the available networks
   *
   * @return Response from the API call
   */
  async getAllTheAvailableNetworks(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicNetwork[]>> {
    const req = this.createRequest('GET', '/api/v2/public/networks');
    req.header('Content-Type', 'application/json');
    return req.callAsJson(array(publicNetworkSchema), requestOptions);
  }

  /**
   * Includes whether an org is setup with auth0
   *
   * @param email
   * @return Response from the API call
   */
  async getPublicOrganizationAttributesByUserEmail(
    email: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicOrganizationSchemaV2[]>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ email: [email, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/organizations/${mapped.email}`;
    return req.callAsJson(
      array(publicOrganizationSchemaV2Schema),
      requestOptions
    );
  }

  /**
   * Cancel Stripe payment session
   *
   * @param body
   * @return Response from the API call
   */
  async cancelStripePaymentSession(
    body?: PaymentsCancelCheckoutInput,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest(
      'POST',
      '/api/v2/public/payment-integrations/cancel-stripe-session'
    );
    const mapped = req.prepareArgs({
      body: [body, optional(paymentsCancelCheckoutInputSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.call(requestOptions);
  }

  /**
   * Redirect to Stripe onboarding page
   *
   * @param integrationId
   * @return Response from the API call
   */
  async redirectToStripeOnboardingPage(
    integrationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      integrationId: [integrationId, string()],
    });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/payment-integrations/setup-stripe-payments-refresh/${mapped.integrationId}`;
    return req.call(requestOptions);
  }

  /**
   * Redirect to Stripe onboarding page
   *
   * @param integrationId
   * @return Response from the API call
   */
  async redirectToStripeOnboardingPage1(
    integrationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      integrationId: [integrationId, string()],
    });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/payment-integrations/setup-stripe-payments-result/${mapped.integrationId}`;
    return req.call(requestOptions);
  }

  /**
   * Get the item that is redeemable for the given key
   *
   * @param key
   * @return Response from the API call
   */
  async getTheItemThatIsRedeemableForTheGivenKey(
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GetClaimOutput>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ key: [key, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/redeem/${mapped.key}`;
    return req.callAsJson(getClaimOutputSchema, requestOptions);
  }

  /**
   * This sends the collectible to the specified address, if the pin is valid.
   *
   * @param key
   * @param body
   * @return Response from the API call
   */
  async redeemClaim(
    key: string,
    body?: PublicRedeemClaimBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicItem>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      key: [key, string()],
      body: [body, optional(publicRedeemClaimBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/public/redeem/${mapped.key}`;
    return req.callAsJson(publicItemSchema, requestOptions);
  }

  /**
   * Get API status
   *
   * @return Response from the API call
   */
  async getAPIStatus(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<StatusResponse>> {
    const req = this.createRequest('GET', '/api/v2/public/status');
    req.header('Content-Type', 'application/json');
    return req.callAsJson(statusResponseSchema, requestOptions);
  }

  /**
   * Must specify org_id and network_id that will be searched. Additionally, the tokens can be restricted
   * to one or more contract addresses.
   *
   * @param orgId
   * @param ethAddress
   * @param networkId
   * @param contractAddress
   * @return Response from the API call
   */
  async getAllItemsOwnedByAnEthAddress(
    orgId: string,
    ethAddress: string,
    networkId: number[],
    contractAddress: string[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicItemOwnership[]>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      orgId: [orgId, string()],
      ethAddress: [ethAddress, string()],
      networkId: [networkId, array(number())],
      contractAddress: [contractAddress, array(string())],
    });
    req.header('Content-Type', 'application/json');
    req.query('network_id', mapped.networkId);
    req.query('contract_address', mapped.contractAddress);
    req.appendTemplatePath`/api/v2/public/tokens/${mapped.orgId}/${mapped.ethAddress}`;
    return req.callAsJson(array(publicItemOwnershipSchema), requestOptions);
  }

  /**
   * This sends a pin code to the email registered on file for this claim.
   *
   * @param key
   * @return Response from the API call
   */
  async verifyClaim(
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicItem>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ key: [key, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/verify-claim/${mapped.key}`;
    return req.callAsJson(publicItemSchema, requestOptions);
  }

  /**
   * Get all collections by an organization
   *
   * @param orgId
   * @return Response from the API call
   */
  async getAllCollectionsByAnOrganization(
    orgId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicCollectionOutput[]>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orgId: [orgId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/public/${mapped.orgId}/collections`;
    return req.callAsJson(array(publicCollectionOutputSchema), requestOptions);
  }

  /**
   * Public items have been minted, and each has a valid token address and token id.
   *
   * @param orgId
   * @param networkId
   * @param collectionId
   * @param attribute
   * @param cursor          SafeString
   * @param limit           Uint
   * @param orderBy
   * @param orderDirection
   * @return Response from the API call
   */
  async getAllPublicItemsFromAnOrganization(
    orgId: string,
    networkId: number[],
    collectionId: string[],
    attribute: string[],
    cursor?: string,
    limit?: number,
    orderBy?: OrderBy10Enum,
    orderDirection?: OrderDirection9Enum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicItemsPaginatedResult>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      orgId: [orgId, string()],
      networkId: [networkId, array(number())],
      collectionId: [collectionId, array(string())],
      attribute: [attribute, array(string())],
      cursor: [cursor, optional(string())],
      limit: [limit, optional(number())],
      orderBy: [orderBy, optional(orderBy10EnumSchema)],
      orderDirection: [orderDirection, optional(orderDirection9EnumSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.query('network_id', mapped.networkId);
    req.query('collection_id', mapped.collectionId);
    req.query('attribute', mapped.attribute);
    req.query('cursor', mapped.cursor);
    req.query('limit', mapped.limit);
    req.query('order_by', mapped.orderBy);
    req.query('order_direction', mapped.orderDirection);
    req.appendTemplatePath`/api/v2/public/${mapped.orgId}/items`;
    return req.callAsJson(publicItemsPaginatedResultSchema, requestOptions);
  }
}
