/**
 * Treum Platform APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  CancelItemListingBody,
  cancelItemListingBodySchema,
} from '../models/cancelItemListingBody';
import { EditItemBody, editItemBodySchema } from '../models/editItemBody';
import { Item, itemSchema } from '../models/item';
import {
  ProvisionItemBody,
  provisionItemBodySchema,
} from '../models/provisionItemBody';
import { SellItemBody, sellItemBodySchema } from '../models/sellItemBody';
import {
  TransferItemBody,
  transferItemBodySchema,
} from '../models/transferItemBody';
import { number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class ItemsController extends BaseController {
  /**
   * Delete item by id
   *
   * @param itemId
   * @return Response from the API call
   */
  async deleteItemById(
    itemId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ itemId: [itemId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}`;
    return req.call(requestOptions);
  }

  /**
   * Get an item by id
   *
   * @param itemId
   * @return Response from the API call
   */
  async getAnItemById(
    itemId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ itemId: [itemId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * This is a full update -- all attributes specified will overwrite ALL existing attributes and item-
   * type specific attributes must be valid against the item type schema. (if any) Attributes cannot be
   * updated once an item has been minted.
   *
   * @param itemId
   * @param body
   * @return Response from the API call
   */
  async updateAnItem(
    itemId: string,
    body?: EditItemBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      itemId: [itemId, string()],
      body: [body, optional(editItemBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * Cancel an active listing
   *
   * @param itemId
   * @param body
   * @return Response from the API call
   */
  async cancelAnActiveListing(
    itemId: string,
    body?: CancelItemListingBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      itemId: [itemId, string()],
      body: [body, optional(cancelItemListingBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}/cancel-listing`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * The standard action is mint with an optional quantity (ERC1155 only).
   *
   * * To mint an ERC721 token: `{"action": "mint"}`
   * * To mint 5 ERC1155 tokens: `{"action": "mint", "parameters": {"quantity": "5"}}`
   *
   * Minting will be done async, callers should either poll the status of this item or use webhooks to
   * listen for mints.
   *
   * @param itemId
   * @param body
   * @return Response from the API call
   */
  async provisionATokenInTheNFTContract(
    itemId: string,
    body?: ProvisionItemBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      itemId: [itemId, string()],
      body: [body, optional(provisionItemBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}/provision`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * This makes no guarantees on if/when the request will be made. This is only applicable to items
   * linked to external contracts.
   *
   * @param itemId
   * @return Response from the API call
   */
  async requestAMetadataRefresh(
    itemId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ itemId: [itemId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}/refresh-metadata`;
    return req.call(requestOptions);
  }

  /**
   * Create a listing for the item. The market_data is dynamic based on the market_type. Please reach out
   * for more information.
   *
   * @param itemId
   * @param body
   * @return Response from the API call
   */
  async putAnItemUpForSale(
    itemId: string,
    body?: SellItemBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      itemId: [itemId, string()],
      body: [body, optional(sellItemBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}/sell`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * This transfers an item that is currently owned by the current organization to another ethereum
   * address.
   *
   * @param itemId
   * @param body
   * @return Response from the API call
   */
  async transferAnItem(
    itemId: string,
    body?: TransferItemBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      itemId: [itemId, string()],
      body: [body, optional(transferItemBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/items/${mapped.itemId}/transfer`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * This makes no guarantees on if/when the request will be made. This is only applicable to items
   * linked to external contracts.
   *
   * @param networkId
   * @param contractAddress
   * @param tokenId
   * @return Response from the API call
   */
  async requestAMetadataRefreshForTheGivenTokenId(
    networkId: number,
    contractAddress: string,
    tokenId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      networkId: [networkId, number()],
      contractAddress: [contractAddress, string()],
      tokenId: [tokenId, number()],
    });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/items/${mapped.networkId}/${mapped.contractAddress}/${mapped.tokenId}/refresh-metadata`;
    return req.call(requestOptions);
  }
}
