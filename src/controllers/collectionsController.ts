/**
 * Treum Platform APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  CollectionAbiOutput,
  collectionAbiOutputSchema,
} from '../models/collectionAbiOutput';
import {
  CreateBulkItemApiOutput,
  createBulkItemApiOutputSchema,
} from '../models/createBulkItemApiOutput';
import {
  CreateBulkItemForCollectionBody,
  createBulkItemForCollectionBodySchema,
} from '../models/createBulkItemForCollectionBody';
import {
  CreateItemForCollectionBody,
  createItemForCollectionBodySchema,
} from '../models/createItemForCollectionBody';
import {
  CreateProductInput,
  createProductInputSchema,
} from '../models/createProductInput';
import {
  DeployCustomTokenContractBody,
  deployCustomTokenContractBodySchema,
} from '../models/deployCustomTokenContractBody';
import {
  DeployTokenContractBody,
  deployTokenContractBodySchema,
} from '../models/deployTokenContractBody';
import { Item, itemSchema } from '../models/item';
import {
  LinkExternalContractBody,
  linkExternalContractBodySchema,
} from '../models/linkExternalContractBody';
import {
  ProductResponse,
  productResponseSchema,
} from '../models/productResponse';
import { array, optional, string } from '../schema';
import { BaseController } from './baseController';

export class CollectionsController extends BaseController {
  /**
   * Get all collections
   *
   * @return Response from the API call
   */
  async getAllCollections(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse[]>> {
    const req = this.createRequest('GET', '/api/v2/collections');
    req.header('Content-Type', 'application/json');
    return req.callAsJson(array(productResponseSchema), requestOptions);
  }

  /**
   * Create a new collection
   *
   * @param body
   * @return Response from the API call
   */
  async createANewCollection(
    body?: CreateProductInput,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('POST', '/api/v2/collections');
    const mapped = req.prepareArgs({
      body: [body, optional(createProductInputSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(productResponseSchema, requestOptions);
  }

  /**
   * Delete a collection
   *
   * @param collectionId
   * @return Response from the API call
   */
  async deleteACollection(
    collectionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ collectionId: [collectionId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}`;
    return req.call(requestOptions);
  }

  /**
   * Get a collection by id
   *
   * @param collectionId
   * @return Response from the API call
   */
  async getACollectionById(
    collectionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ collectionId: [collectionId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}`;
    return req.callAsJson(productResponseSchema, requestOptions);
  }

  /**
   * This is a partial update, only attributes present will be updated.
   *
   * @param collectionId
   * @param body
   * @return Response from the API call
   */
  async editACollection(
    collectionId: string,
    body?: CreateProductInput,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      body: [body, optional(createProductInputSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}`;
    return req.callAsJson(productResponseSchema, requestOptions);
  }

  /**
   * Get a collection ABI by id
   *
   * @param collectionId
   * @return Response from the API call
   */
  async getACollectionABIById(
    collectionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CollectionAbiOutput>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ collectionId: [collectionId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/abi`;
    return req.callAsJson(collectionAbiOutputSchema, requestOptions);
  }

  /**
   * The contract _must_ have one of the following capabilities:
   * * `ERC721`
   * * `ERC1155`
   *
   * Otherwise, the contract will be rejected.
   *
   * In order to being able to mint collectibles through the platform, the contract _should_ have one of
   * the following capabilities:
   * * `ADMIN_MINT_SINGLE` (for ERC721)
   * * `ADMIN_MINT_MULTIPLE`  (for ERC1155)
   * * `ADMIN_MINT_SINGLE_URI` (for ERC721)
   *
   * Capabilities are determined by the contract's ABI. You can get the known capabilities ABIs from the
   * endpoint `/v2/public/capabilities`
   *
   * @param collectionId
   * @param body
   * @return Response from the API call
   */
  async deployACustomTokenContractForANewCollection(
    collectionId: string,
    body?: DeployCustomTokenContractBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      body: [body, optional(deployCustomTokenContractBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/contract`;
    return req.callAsJson(productResponseSchema, requestOptions);
  }

  /**
   * Deploy the token contract for the collection
   *
   * @param collectionId
   * @param body
   * @return Response from the API call
   */
  async deployTheTokenContractForTheCollection(
    collectionId: string,
    body?: DeployTokenContractBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      body: [body, optional(deployTokenContractBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/deploy`;
    return req.callAsJson(productResponseSchema, requestOptions);
  }

  /**
   * Get all items associated with this collection
   *
   * @param collectionId
   * @return Response from the API call
   */
  async getAllItemsAssociatedWithThisCollection(
    collectionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item[]>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ collectionId: [collectionId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/items`;
    return req.callAsJson(array(itemSchema), requestOptions);
  }

  /**
   * Create a new item associated with the given collection
   *
   * @param collectionId
   * @param body
   * @return Response from the API call
   */
  async createANewItemAssociatedWithTheGivenCollection(
    collectionId: string,
    body?: CreateItemForCollectionBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Item>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      body: [body, optional(createItemForCollectionBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/items`;
    return req.callAsJson(itemSchema, requestOptions);
  }

  /**
   * Create a bulk set of items associated with the given collection
   *
   * @param collectionId
   * @param body
   * @return Response from the API call
   */
  async createABulkSetOfItemsAssociatedWithTheGivenCollection(
    collectionId: string,
    body?: CreateBulkItemForCollectionBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CreateBulkItemApiOutput>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      body: [body, optional(createBulkItemForCollectionBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/items/bulk`;
    return req.callAsJson(createBulkItemApiOutputSchema, requestOptions);
  }

  /**
   * Link external contract to the collection
   *
   * @param collectionId
   * @param body
   * @return Response from the API call
   */
  async linkExternalContractToTheCollection(
    collectionId: string,
    body?: LinkExternalContractBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      collectionId: [collectionId, string()],
      body: [body, optional(linkExternalContractBodySchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/link-external-contract`;
    return req.callAsJson(productResponseSchema, requestOptions);
  }

  /**
   * This makes no guarantees on if/when the request will be made. This is only applicable to items
   * linked to external contracts.
   *
   * @param collectionId
   * @return Response from the API call
   */
  async requestAMetadataRefreshForTheGivenCollection(
    collectionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ collectionId: [collectionId, string()] });
    req.header('Content-Type', 'application/json');
    req.appendTemplatePath`/api/v2/collections/${mapped.collectionId}/refresh-metadata`;
    return req.call(requestOptions);
  }
}
